\section{\ref{rq:finding-changes} How can we find changes between two models?}

Finding changes is handled in the \verb|Testar.ChangeDetection.Core.Algorithm| namespace. The algorithm can be used by different project, for example by an application for CI integration. The visualisation of the differences are handled by the new analysis website and discussed in section \ref{rq:type-visualisation-answer}

The classes used for the algorithm are visualised in Figure \ref{fig:class-diagram-differences}. For visibility purposes the interfaces and external dependencies are omitted.

\begingroup
\captionsetup{type=figure}
\includegraphics[scale=0.5]{thesis/images/4-UML-Differences.png}
\captionof{figure}{Class diagram differences (UML 2.0)}\label{fig:class-diagram-differences}
\endgroup

\subsection{The change detection algorithm}

The core of the algorithm is implemented by the \verb|GraphCompareEngine| class. The \verb|CompareAsync| method is given two app models, \verb|model1| and \verb|model2|. The \verb|GraphCompareEngine| has three dependencies, i.e. graph retriever (\verb|IRetrieveGraphForComparison|), a graph starter (\verb|IStartingAbstractState|) and the vertex comparer (\verb|ICompareVertices|). The dependencies are discussed below. 

\subsubsection{Graph retriever}
The graph retriever \verb|IRetrieveGraphForComparison|) is implemented by the \verb|GraphForCompareRetriver|. It has a dependency on the graph service, that downloads the graph elements from the server. 

Given a \verb|Model| it will get the data from the abstract Layer, the concrete Layer and the abstract concrete connectors. After the data is downloaded, it enriches the abstract actions with the \verb|description| from a corresponding concrete action. The result is a \verb|AppGraph|.

\begingroup
\captionsetup{type=figure}
\includegraphics[scale=0.6]{thesis/images/4-UML-Models.png}
\captionof{figure}{Class diagram Graph models (UML 2.0)}\label{fig:class-diagram-models}
\endgroup

The \verb|AppGraph|, shown in figure \ref{fig:class-diagram-models}, is wrapper around a collection of \verb|GraphElement|. The \verb|GraphElement| is container a abstract Document which is either a Vertex or an Edge. The abstract \verb|Document| class contains the properties from the vertex or the Edge. When the \verb|AppGraph| is serialised into JSON, it will generated the structure that can be read by the Cytoscape Graph visualisation library.

Although the data for each element is located in a set of properties, the classes in figure \ref{fig:class-diagram-models} contains some helper properties, e.g. \verb|IsAbstractAction| and \verb|IsConcreteState| which returns a boolean depending on the type name. 

An alternative implementation can be provided by implementing the \verb|IRetrieveGraphForComparison| and register it in the dependency injection framework.

\subsubsection{Graph starter}
It could be possible to start anywhere in the model to c


The compare engine need to have an place to start with the comparison. 


Due to the nature of the algorithm, explained later in this section, it needs to known where to start. This task is implemented by the \verb|InitialStartingAbstractState| class. For now it is assumed that the initial abstract state are corresponding states. Different starting strategies can be implemented by implementing the \verb|IStartingAbstractState| interface. 

\subsubsection{Vertex comparer}
\begin{algorithm}
\caption{Vertex comparison}\label{alg:cap}
\begin{algorithmic}
\Require Properties of old model
\Require Properties of new model
\State $O$ = Properties of old model
\State $N$ = Properties of new model
\For{$p \in$ $(O \cup N)$}
    \State Mark $p$ as \textit{Added} in new model
\EndFor
\For{$p \in$ $(N \cup O)$}
    \State Mark $p$ as \textit{Removed} in old model
\EndFor
\For{$p \in$ $(O \cap N)$}
    \State $Ov$ = value of property in old model
    \State $Nv$ = value of property in new model
    \If{$Ov \neq Nv$}
       \State Mark property as changed 
    \EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

\subsubsection{Compare algorithm} \label{sec:compare-algorithm}



% TODO give brief summary to explain terminology like corresponding states, walk over actions etc. 

The second step of the algorithm is the determining where to start the change detection. This can be 






%Abstract Graph comparison
%First the software create a ComparableGraph. A Comparable graph only contacts the nodes and edges from the abstract states and abstract actions. The data however will include data from the concrete states and actions. 

%When we have a changed abstractstate, get a widgettree of one concrete state
%https://www.xmlunit.org/  have a package for both java as .NET to create differences between version.

%using a fast mode
%the fast mode will only look into changes on the abstract level. Changes like different colours for example


% Every element has an ID generated by OrientDb e.g. #154:0. When merging elements those Id's are merged to by the following algorithm: \#Id1\_Id2 e.g. \#150:0\_\#150:1. 

difference engine
merge graph \cite{andrews2009visual}
the graph needs to be similar are "enough"

Finding matching notes is done by the difference algorithm. 




\subsection{Calibration}
\subsection{Difference Engine}
\subsection{Difference Graph}
